![](Pasted%20image%2020240401205744.png)
![](Pasted%20image%2020240401205803.png)

![](Pasted%20image%2020240326163502.png)
软件规模度量单位
LOC（Lines of Code） 
	 代码行：用源代码长度的测量 
FP（Function Points） 
	 功能点：用系统的功能点数量来测量 
UCP（Use Case Points） 
	 用例点：用系统的用例点数量来测量

# 传统估算
## 代码行估算法 
优点
	代码是所有软件开发项目都有的“产品”，而且很容易计算代码行数
缺点
	1. 对代码行没有公认的可接受的标准定义 
	2. 代码行数量依赖于所用的编程语言和个人的编程风格 
	3. 在项目早期，需求不稳定、设计不成熟、实现不确定的情况下很难准确地估算代码量 
	4. 代码行强调编码的工作量，只是项目实现阶段的一部分，其他阶段无代码产生

## 功能点估算法 
 与实现的语言和技术没有关系 
 用系统的功能数量来测量其规模 
 通过评估、加权、量化得出功能点 
 估算软件规模，即软件规模度量单位
注：功能点 ≠ 软件系统中的可以运行的功能模块
![](Pasted%20image%2020240326163943.png)
### UFC
UFC=功能复杂度系数×功能数
![](Pasted%20image%2020240326164146.png)

![](Pasted%20image%2020240326170043.png)

### TCF
$TCF = 0.65 + 0.01 × ∑_{i=1\ to\ 14} F_i$
![](Pasted%20image%2020240326170529.png)

### FP
$FP = UFC×TCF$
![](Pasted%20image%2020240326170804.png)

### Effort
项目工作量 $Effort = FP × PE$

### 功能点与代码行的转换标准
![](Pasted%20image%2020240326170851.png)


## 用例点估算法 
![](Pasted%20image%2020240326170938.png)
### 1. 计算未调整的角色权值 UAW
$UAW = ∑_{C=c} aWeight(c)×aCardinality(c)$
![](Pasted%20image%2020240326173521.png)

### 2. 计算未调整的用例权值 UUCW
$UUCW = ∑_{C=c} uWeight(c)×uCardinality(c)$
![](Pasted%20image%2020240326173542.png)

### 3. 计算未调整的用例点 UUCP 
$UUCP = UAW + UUCW$

### 4. 计算技术复杂度因子 TCF 
$TCF = 0.6 + ( 0.01×∑_{i=1\ to\ 13} TCF\_Weight_i×Value_i )$
![](Pasted%20image%2020240326174007.png)

### 5. 计算环境复杂度因子 ECF 
$ECF = 1.4 + ( -0.03×∑_{i=1\ to\ 8} ECF\_Weight_i×Value_i )$
![](Pasted%20image%2020240326182646.png)

### 6. 计算调整的用例点 UCP 
根据（1）未调整的用例点 UUCP、（2）技术复杂度因子 TCF、（3）环境复杂度因子 ECF，可以计算出调整后的用例点 UCP
$UCP = UUCP × TCF × ECF$

### 7. 计算工作量 Effort
项目工作量 $Effort = UCP × PE$


## 类比估算法 
估算人员根据以往的完成类似项目所消耗的总成本（或工作量），来推算将要开发的软件的总成本（或工作量）
适用情况 
	 有类似的历史项目数据 
	 信息不足（例如市场招标）的时候 
	 要求不是非常精确估算的时候
### 计算公式
![](Pasted%20image%2020240326183955.png)

## 自下而上估算法 
 利用任务分解图 (WBS)，对各个具体工作包进行详细的成本估算, 然后将结果累加起来得出项目总成本
![](Pasted%20image%2020240401205158.png)
 相对比较准确，它的准确度来源于每个任务的估算情况 
 花费时间
![](Pasted%20image%2020240401205244.png)

## 三点估算法 
 基于任务成本的 3 种估算值 (即最有可能成本、最乐观成本、最悲观成本）来加权平均计算预期成本的方法
 CM：Most possible Cost，最可能成本，比较现实的估算成本 
 CO：Optimistic Cost，最乐观成本，最好情况预期所得到的估算成本 
 CP：Pessimistic Cost，最悲观成本，最差情况预期所得到的估算成本 
 CE=f (CO, CM, CP) 
	CE 即 Expected Cost，预期成本，通过 CO、CM、CP 来计算
- F (CO, CM, CP)
（1）三角分布: CE = ( CO + CM + CP) / 3 
（2）贝塔分布: CE = ( CO + 4 CM + CP) / 6

## 专家估算法
 由多位专家进行成本估算，一个专家可能会有偏见，最好由多位专家进行估算，取得多个估算值，最后得出综合的估算值
### Delphi 专家估算法 
1. 组织者确定一批专家，规定：这些专家互相不见面 
2. 组织者发给每位专家一份软件规格说明（重点 WBS）以及估算值记录表 
3. 每位专家认真研究软件规格说明书，以无记名方式对该软件给出 3 个规模的估算值：最小值 ai、最可能值 mi、最大值 bi 
4. 组织者整理并计算每位专家估算的结果： 
	Ei = ( ai + 4 mi + bi ) / 6 【贝塔分布算法】 
5. 最终可以获得一个多数专家共识的软件规模：
	E = (E 1 + E 2 + … + En) / n 【n - 专家数量】 
6. 如果各个专家的估算差异超出规定的范围（例如：15%），则需重复上述过程
![](Pasted%20image%2020240401205642.png)

# 现代敏捷估算
 采用轻量级估算方法快速生成高层级估算 
 短期规划可以进行详细的估算
## 故事点估算法
 Story Point（故事点）用来度量实现一个 Story 需要付出的工作量的相对估算值 
 例如：A 任务工作量为 1 个 Story Point， B 任务工作量为 2 个 Story Points，则认为： B 工作量 = 2 倍的 A 工作量
### 统一估算基准 - 参照基准
 Fibonacci 数列： 0，1，2，3，5，8，13，21，34，55，89，… 
Fibonacci 标准的 7 个等级  0、1、2、3、5、8、13 七个等级 
1. 选取预估为 3 Story Points 的某个 Story，假设名字为 A 
2. 将需要预估的 Story 与 Story A 进行比较 
3. 如果 2 个 Story 工作量差不多，设置该 Story 的 Story Point 为 3 
4. 如果工作量略少，则设置为 2 
5. 如果工作量更少，则设置为 1 
6. 如果该 Story 不需要完成，则设置为 0 
7. 同理，如果略多/更多/再多，可以相应的设置为 5/8/13 
8. 如果该 Story 超过 13 Story Points，可以认为是 Epic，可以再分解

 2 n 数列： 0，1，2，4，8，16，32，64，128，…

### 快速故事点估算 (Fast Story Point Estimation）
 快速、粗略估算；过程有趣，杜绝枯燥、乏味、繁琐
前提条件： 
 团队成员理解大多数用户故事的要点 
 有同地协作的团队 
 每个用户故事独立打印，必须在估算过程之前准备好，并贴在墙上

### 计划扑克估算（Planning Poker）
 详细估算：可以设定相应规则
