# 预测型过程模型 (Predictive model)
## 瀑布模型 (Waterfall)
将 SDLC 各项活动规定为按固定顺序而连接的若干阶段工作，形如瀑布流水，最终得到软件产品
也叫做鲑鱼模型 (Salmon model)：向前一阶段回溯，很难!
### 特点
-  上一个阶段结束，下一个阶段才能开始  
-  每个阶段均有里程碑和提交物 
-  上一阶段输出是下一阶段输入 
-  每个阶段均需要进行 V&V 
-  侧重于文档与产出物
![](Pasted%20image%2020240324142718.png)

### 优缺点
优点——追求效率 
– 简单、易懂、易用、快速 
– 为项目提供了按阶段划分的检查点，项目管理比较容易 
– 每个阶段必须提供文档，而且要求每个阶段的所有产品必须进行正式、严格的技术审查 
缺点——过于理想化
– 在开发早期，用户难以清楚地确定所有需求，需求的错误很难在开发后期纠正，因此难以快速响应用户需求变更 
– 开发人员与用户之间缺乏有效的沟通，开发人员的工作几乎完全依赖规格说明文档，容易导致不能满足客户需求 
– 客户必须在项目接近尾声的时候才能得到可执行的程序，对系统中存在的重大缺陷，如果在评审之前没有被发现，将可能会造成重大损失
### 适用场合
– 软件项目较小，各模块间接口定义非常清晰 
– 需求在项目开始之前已经被全面的了解，产品的定义非常稳定 
– 需求在开发中不太可能发生重大改变 
– 使用的技术非常成熟，团队成员都很熟悉这些技术 
– 负责各个步骤的子团队分属不同的机构或不同的地理位置，不可能做到频繁的交流 
– 外部环境的不可控因素很少

## V 模型 (V Model)
V 模型是瀑布模型的一种变形，强调测试的重要性，将开发活动与测试活动紧密联系在一起
![](Pasted%20image%2020240324142754.png)

## W 模型（W Model）
相对于 V 模型，W 模型增加了软件开发各阶段中同步进行的验证和确认活动 
-  由两个 V 字型模型组成，分别代表测试与开发过程，明确表示出了测试与开发的并行关系 
-  W 模型同样强调测试的重要性，将开发活动与测试活动紧密联系在一起
![](Pasted%20image%2020240324142850.png)

## V 模型与 W 模型的优缺点 
-   优点——开发过程重视测试/验证 
– 简单易用，只要按照规定的步骤执行即可 
– 强调测试或验证与开发过程的对应性和并行性；测试方案在编码之前就已经制定了 
– 与瀑布模型相比，项目开发成功的机会更高 
– 避免缺陷向下游流动 
-  缺点
– 比瀑布模型繁琐

## 形式化过程 (Formal model)
![](Pasted%20image%2020240324144525.png)
### -  优点： 
– 应用数学分析方法，歧义性、不完整性、不一致性等问题更容易被发现和改正，目的是“提供无缺陷的软件” 
### -  缺陷： 
– 形式化数学方法难以理解，可视性太差，对开发人员技能要求较高 
– 构造形式化模型是一件非常耗时的工作，成本也很高 
– 软件系统中的某些方面难以用形式化模型表达出来（如用户界面） 
### -  应用场合： 
– 对可靠性和安全性要求较高的一些关键系统，在真正被投入使用之前，需要严格保证 100%的正确；传统的方法靠人去验证，难以奏效 
——太过于理想化，因此仅停留在理论研究中，实践中很少使用
# 迭代过程模型 (Iterative model)
>软件开发过程面临的客观情况： 
>– 软件系统会随着时间的推移而发生变化，在开发过程中，需求经常发生变化，直接导致产品难以实现 
>– 严格的交付时间使得开发团队不可能圆满完成软件产品，但是必须交付功能有限的版本以应对竞争或压力 
>– 很好的理解核心产品与系统需求，但对其他扩展的细节问题却没有定义 

在上述情况下，需要一种专门应对不断演变的软件过程模型，即“迭代过程模型” 
-  本质：循环、反复、不断调整当前系统以适应需求变化

-  迭代过程模型的目的：
– 需求的变更频繁，要求在非常短的期限内实现，以充分满足客户/用户要求、及时投入市场 
-   存在的问题： 
– 由于构建产品所需的周期数不确定，给项目管理带来困难 
– 迭代速度太快，项目陷入混乱；迭代速度太慢，影响生产率 
– 为追求软件的高质量而牺牲了开发速度、灵活性和可扩展性
## 快速原型法 (Prototype)
![](Pasted%20image%2020240324143720.png)
![](Pasted%20image%2020240324143742.png)
### 优缺点
-  优点：
– 提高和改善客户/用户的参与程度，最大程度的响应用户需求的变化 
– 克服预测型模型的缺点，减少由于需求不够明确带来的开发风险 
-   缺点： 
– 为了尽快完成原型，开发者没有考虑整体软件的质量和长期的可维护性，系统结构通常较差 
– 可能混淆原型系统与最终系统，原型系统在完全满足用户需求之后可能会被直接交付给客户使用 
– 额外的开发费用

## 螺旋模型 (Spiral)
与增量、RAD 等的最大区别在于<u>重视风险评估</u>
- 螺旋模型沿着螺线旋转，在四个象限内表达四个方面的活动： 
– 制定计划：确定软件目标，选定实施方案，弄清项目开发的限制 
– 风险分析：分析所选方案，考虑如何识别和消除风险 
– 实施工程：实施软件开发 
– 客户评估：评价开发工作，提出修正建议
- 出发点：开发过程中及时识别和分析风险，并采取适当措施以消除或减少风险带来的危害
![](Pasted%20image%2020240324144221.png)
### 优缺点
-  优点：结合了原型的迭代性质与瀑布模型的系统性和可控性，是一种风险驱动型的过程模型： 
– 采用循环的方式逐步加深系统定义和实现的深度，同时更好的理解、应对和降低风险 
– 确定一系列里程碑，确保各方都得到可行的系统解决方案 
– 始终保持可操作性，直到软件生命周期的结束 
– 由风险驱动，支持现有软件的复用 
-  缺陷： 
– 适用于大规模软件项目，特别是内部项目，周期长、成本高 
– 软件开发人员应该擅长寻找可能的风险，准确的分析风险，否则将会带来更大的风险

# 增量过程模型 (Incremental process model)
> -  在很多情况下，由于初始需求的不明确，开发过程不宜采用瀑布模型等预测性模型 
> -  因此，无须等到所有需求都出来才进行开发，只要某个需求的核心部分确定下来，即可进行开发 
> -  另外，可能迫切需要为用户迅速提供一套功能有限的软件产品，然后在后续版本中再细化和扩展功能

在这种情况下，需要选用增量方式的软件过程模型
## 增量模型 (Incremental)
软件被作为一系列的增量来设计、实现、集成和测试，每一个增量是由多个相互作用的模块所形成的特定功能模块或功能模块组 
-   本质：以迭代的方式运用瀑布模型
– 第一个增量往往是核心产品：满足了基本的需求，但是缺少附加的特性 
– 客户使用上一个增量的提交物并进行自我评价，制定下一个增量计划，说明需要增加的特性和功能 
– 重复上述过程，直到最终产品开发完成为止
### 优点
– 在时间要求较高的情况下交付产品：在各个阶段并不交付一个可运行的完整产品，而是交付满足客户需求的一个子集的可运行产品，对客户起到“镇静剂”的作用 
– 人员分配灵活：如果找不到足够的开发人员，可采用增量模型：早期的增量由少量人员实现，如果客户反馈较好，则在下一个增量中投入更多的人力 
– 逐步增加产品功能可以使用户有较充裕的时间来学习和适应新产品，避免全新软件可能带来的冲击 
– 因为具有较高优先权的模块被首先交付，而后面的增量也不断被集成进来，这使得最重要的功能肯定接受了最多的测试，从而使得项目总体性失败的风险比较低
### 困难
– 每个附加的增量并入现有软件时，必须不破坏原来已构造好的部分 
– 同时，加入新增量时应简单、方便 ——该类软件的体系结构应当是开放的 
– 仍然无法处理需求发生变更的情况 
– 管理人员必须有足够的技术能力来协调好各增量之间的关系

## RAD 模型
快速应用开发 RAD (Rapid Application Development) 
– 侧重于短开发周期（一般为 60~90 天）的增量过程模型，是瀑布模型的高速变体，通过基于构件的构建方法实现快速开发 
– 多个团队并行进行开发，但启动时间有先后，先启动团队的提交物将作为后启动团队的输入
### 缺点
– 需要大量的人力资源来创建多个相对独立的 RAD 团队 
– 如果没有在短时间内为急速完成整个系统做好准备，RAD 项目将会失败 
– 如果系统不能被合理的模块化，RAD 将会带来很多问题 
– 技术风险很高的情况下（采用很多新技术、软件需与其他已有软件建立集成等等），不宜采用 RAD

# 敏捷过程模型 (Agile model)
## 特点
本质：以快速的增量和迭代方式进行软件开发
### 为何要“敏捷”？
- 开发过程中的“变化”是无处不在的，也是不可避免的 
- 在实际项目中，很难预测需求和系统何时以及如何发生变化 
- 对开发者来说，应将变化的意识贯穿在每一项开发活动中
### 固定节奏、小步快跑、及时反馈、应对变化、快速交付
- 不强调文档，转向强调可运行的软件片段 
- 开发者与客户之间频繁沟通 
- 快速开发，快速反馈，快速修改，增量交付 
- 连续不断的短周期迭代 
- 工作节奏稳定，不提倡加班 
- 不看重形式和工具，看重“人”和内容，保持简洁
## 极限编程 (XP)
![](Pasted%20image%2020240324150725.png)
![](Pasted%20image%2020240324150801.png)
![](Pasted%20image%2020240324150824.png)
极限：把某件事情做到极致
![](Pasted%20image%2020240324151218.png)
### Pair Programming：结对编程
每人在各自独立设计、实现软件的过程中不免要犯这样那样的错误；在结对编程中，因为有随时的复审和交流，程序各方面的质量取决于一对程序员中各方面水平较高的那一位；这样，程序中的错误就会少得多，程序的初始质量会高很多，这样会省下很多以后修改、测试的时间

## Scrum
![](Pasted%20image%2020240324151256.png)

Scrum 中的三种角色
-  Product Owner （产品负责人）：确定产品的功能，负责维护产品 Backlog、deadline、priority、ROI（投资回报率）；验收结果 
-  Scrum Master（团队 leader）：保证开发过程按计划进行；组织每日站会、Sprint 计划会议、Sprint 评审会议和 Sprint 回顾会议；通过外在/内在协调，确保团队资源完全可被利用并且全部是高产出的 
-  Scrum Team（Scrum 团队）：在每个 Sprint 中将产品 Backlog 中的条目转化成为潜在可交付的功能增量；规模在 5-10 人；具备交付产品增量所需要的各种技能

Scrum 中的六项活动 
-  Sprint (冲刺)：代表一个 2-4 周的迭代 
-  发布计划会议 (Release Planning Meeting) 
-  Product Backlog 
-  Sprint 计划会议 (Sprint Planning Meeting) 
-  Sprint Backlog 
-  每日站会 (Daily Scrum Meeting) 
-  Sprint 评审会 (Sprint Review Meeting) 
-  Sprint 回顾会议 (Sprint Retrospective Meeting)

![](Pasted%20image%2020240324151443.png)
## Kanban

## DevOps
[什么是 DevOps？ DevOps 介绍 | Microsoft Azure](https://azure.microsoft.com/zh-cn/resources/cloud-computing-dictionary/what-is-devops)

# 其他过程模型 
## 基于复用的过程模型
-  针对一个新的软件系统，不是完全从一无所有开始入手，而是通过使用已有的软件单元（称为“软构件”）来构造系统 
-  主要过程： 
– 需求分析 
– 体系结构设计 
– 构件获取 (购买 / 重新开发) 
– 构件修改与测试 
– 构件组装 
– 集成测试

# 总结
-  瀑布模型：将全部需求以整体方式向前推进，无迭代 
	—— 基本模型 
-  增量模型：将需求分成多份，串行推进，无迭代 
	—— 串行的瀑布 
-  RAD 模型：将需求分成多份，可并行推进，无迭代 
	—— 并行的瀑布 
-  原型模型：始终结果可见，不断迭代修正原型，直到开发完成 
	—— 基本模型 
-  螺旋模型：按瀑布阶段划分，各阶段分别迭代 (原型+风险分析) 
	—— 原型+瀑布 
-  敏捷模型：将需求分成尽量小的碎片，以碎片为单位进行高速迭代 
	—— 增量+迭代+原型
![](Pasted%20image%2020240324151601.png)
